# 区块链入门知识

1. ### BTC的诞生

   - 起源：08 年全球爆发金融危机，同年 11 月 1 日，一个自称中本聪（ Satoshi Nakamoto）的人在 P2P foundation 网站上发表了比特币的白皮书，《比特币：一种点对点的电子现金系统》2009 年 1 月 3 日，比特币创世区块诞生。点对点传输意味着一个去中心化的支付系统。

2. 比特币的含义：与所有的货币不同，比特币不依靠任何货币机构进行发行，根据初始的设定和算法，通过大量的计算。比特币的经济流转体系使用整个 P2P 网络中众多节点构成的分布式链式数据库来进行记录所有的交易行为。并使用密码学确保货币流通的各个环节的安全。基于密码学之上能够真实的被转移和支付。

3. 总量有限约为21000万枚，其中不少一部分早期挖矿者因为各种问题丢失私钥和硬盘，无法找回。2009年，比特币诞生的时候，每个区块的奖励是50比特币奖励。当出块奖励达到当前总量的一半后减产50%，下一次减产在产生上一次产量的一半后减产。

4. 链上账户的生成无需成本，一定情况下保证了较强的隐匿性。

5. Hash 指针，除了第一个 Block外，每一个区块的 Prev_hash 都是前一个 BLock 的 Hash，如果某一个节点需要修改住主链上的Block的交易，势必改变当前区块的Hash，那么他的下一block 将无法通过Prev_hash 来找到前面一个block。

6. 比特币采用的算法为SHA-256，任意长度的消息，SHA256 都会产生一个 256 位的哈希值，这个摘要相当于是个长度为 32 字节的数组。通常有一个长度 64 的十六进制自字符表示。其中1个字节等于8位。一个十六进制的字符的长度为4位。

7. Merkle Tree 另一个字段 `merkleroot` 其实就是一个 [Merkle 树](https://en.wikipedia.org/wiki/Merkle_tree) 的根节点，它其实是一种使用哈希指针连接的数据结构；虽然 Merkle 树有叶节点和非叶节点，但是它只有叶节点会存储数据，所有的非叶结点都是用于验证数据完整性的哈希。

8. UTXO 模型 作为最早出现的加密货币，Bitcoin 就采用了 UTXO 模型作为其底层存储的数据结构，其全称为 *Unspent Transaction output*，也就是未被使用的交易输出。

   在 Bitcoin 以及其他使用 UTXO 模型的加密货币中，某一个『账户』中的余额并不是由一个数字表示的，而是由当前区块链网络中所有跟当前『账户』有关的 UTXO 组成的。

9. 类比特币，比如LTC、BCH、BSV、BCD... 直接硬分叉或者在比特币的源码上进行修改，重建一条新的链条。

10. 比特币的的速度非常的慢，10分钟出块，每一个最基本的比特币交易为250b，1M=1024kb=1024000/250/600=6.6 TPS。闪电网络是去中心化网络，闪电网络是去中心化网络，基于多签钱包，来进行小额快速转账。

11. btc转账模型，转账根据币龄，转账大小。小于0.01btc，需要支付0.00001btc，币龄大，且转账小于10000字节可以免费转账。





1. ### Etherum

   前言：ETH最初的代币是ETC经典， The Dao通过 ICO 私募当时ETC，由于出现合约问题漏洞，转移了3600万枚ETC，后来V神提出硬分叉，并且得到了90%的算力支持。从而建立的新的ETH。

   

   - Etherum 在 BTC 的基础上引入了账户余额模型，创建使用solidity语言的EVM虚拟机。EVM 虚拟机 是一个完全隔离外部通讯的沙盒。在以以太坊中运行的智能合约不允许访问外部网络。外部文件系统，在其进行。智能合约之间的访问也是受到限制的。但是虚拟机的引入了无限的可能。包括后面的erc20、erc721、erc1155等。
   - 以太坊智能合约和提案 https://github.com/ethereum/EIPs/tree/master/EIPS
   - 合约地址是由合约中的方法控制的，合约设定有管理员地址，那么管理员就有管理这个合约的能力。合约的常用调用中，使用eth原生资产是不需要 approve 的。使用合约中的资产和其他合约进行交互的时候需要进行approve操作的。例如你在uniswap上进行eth、dai 交换 usdc。使用eth 可以直接进行购买。使用dai购买的话需要进行approve uniswap的合约对你账户中的Dai进行授权使用。
   - 通常授权分为两种，限定量授权和无限授权。在交易的时候，我需要使用100个dai交互哪

   

   - 外部账户、也就是用户生成的由公私钥来控制的账户。

   - Etherum account 每一个账户都包含四个字段， nonce，ether_balance,contact_code.storage.

   - Nonce Account 每使用nonce签发并发送一笔交易。都会将其+1，交易的结果是Account 中的ether_balance 的变动，没有UTXO模型，所以引入了nonce来解决重放攻击。

   - contract_code 中的代码，所有的合约在网络中都能够相应其他账户的请求和消息并提供一些服务。

     

   - 合约账户 ，目前最多的合约账户也就是ERC20 合约，我们平常所说的Token 就是Ethereum上的合约，这些合约其实也是Ethereum上的账户。合约账户是由合约中的代码控制的。

   - 新的Account 模型，鄙弃了原先的UTXT记账模型，优化了存储结构，利用nonce来避免重放攻击。新的交易模型，来维护整个网络的安全。
   - Gas price 与 Gas limit 
     - Gas price 单位换算，wei 为最小单位 ，通常我们在转账中使用的是Gwei。当前的进行交易实际上是矿工挑选高的的交易费的交易进行广播打包。具体的gas 其实可以参考gas.now。来进行参考。Gas Pirce 给得太低，矿工不会打包，最后这笔交易会堵塞你的nonce。让你后面的交易无法发出。gas price 给得高，那么矿工会优先打包你的交易。
     - ![img](https://decenter.org/storage/posts/images/hq3e09q3rXWco1edsiH4Gimd5H4lwg2KtCONatly.jpeg)
   - Gas limit 用户愿意为某个操作付出的最大的Gas的量，最少是21000。例如某个用户需要进行合约操作，需要使用 50000 gas limit ，当前的 Gas price 是 20 Gwei，那么用户需要付出20000000000 wei*50000=1000000000000000wei=0.001ETH。Gas limit 设置过低，当前交易会因为gas不足的错误而被取消。gas limit 应当比当前消耗的gas 高才行，消耗剩余的gas 会被退回。

   

   

   #### Layer2

   - 

   

   











1. #### 基本概念

   - 分布式一致性

   - 拜占庭将军问题

     - 拜占庭将军问题是 Leslie Lamport 在 [The Byzantine Generals Problem](https://web.archive.org/web/20170205142845/http://lamport.azurewebsites.net/pubs/byz.pdf) 论文中提出的分布式领域的容错问题，它是分布式领域中最复杂、最严格的容错模型。

       在该模型下，系统不会对集群中的节点做任何的限制，它们可以向其他节点发送随机数据、错误数据，也可以选择不响应其他节点的请求，这些无法预测的行为使得容错这一问题变得更加复杂。

       拜占庭将军问题描述了一个如下的场景，有一组将军分别指挥一部分军队，每一个将军都不知道其它将军是否是可靠的，也不知道其他将军传递的信息是否可靠，但是它们需要通过投票选择是否要进攻或者撤退：

       ![byzantine-generals-problem](https://img.draveness.me/2017-12-18-byzantine-generals-problem.png)

       > 在这一节中，黄色代表状态未知，绿色代表进攻，蓝色代表撤退，最后红色代表当前将军的信息不可靠。

       在这时，无论将军是否可靠，只要所有的将军达成了统一的方案，选择进攻或者撤退其实就是没有任何问题的：

       ![byzantine-generals-problem-with-plans](https://img.draveness.me/2017-12-18-byzantine-generals-problem-with-plans.png)

       上述的情况不会对当前的战局有太多的影响，也不会造成损失，但是如果其中的一个将军告诉其中一部分将军选择进攻、另一部分选择撤退，就会出现非常严重的问题了。

       ![byzantine-generals-problem-split-votes](https://img.draveness.me/2017-12-18-byzantine-generals-problem-split-votes.png)	由于将军的队伍中出了一个叛徒或者信息在传递的过程中被拦截，会导致一部分将军会选择进攻，剩下的一部分会选择撤退，它们都认为自己的选择是大多数人的选择，这时就出现了严重的不一致问题。

       拜占庭将军问题是对分布式系统容错的最高要求，然而这不是日常工作中使用的大多数分布式系统中会面对的问题，我们遇到更多的还是节点故障宕机或者不响应等情况，这就大大简化了系统对容错的要求；不过类似 Bitcoin、Ethereum 等分布式系统确实需要考虑拜占庭容错的问题，我们会在下面介绍它们是如何解决的。

   - #### POW(Proof-of-Work)

     - 上一节介绍的共识算法，无论是 Paxos 还是 Raft 其实都只能解决非拜占庭将军容错的一致性问题，不能够应对分布式网络中出现的极端情况，但是这在传统的分布式系统都不是什么问题，无论是分布式数据库还是消息队列集群，它们内部的节点并不会故意的发送错误信息，在类似系统中，最常见的问题就是节点失去响应或者失效，所以它们在这种前提下是有效可行的，也是充分的。

       这一节介绍的 [工作量证明](https://en.wikipedia.org/wiki/Proof-of-work_system)（POW，Proof-of-Work）是一个用于阻止拒绝服务攻击和类似垃圾邮件等服务错误问题的协议，它在 1993 年被 Cynthia Dwork 和 Moni Naor 提出，它能够帮助分布式系统达到拜占庭容错。

       ![proof-of-work-puzzle](https://img.draveness.me/2017-12-18-proof-of-work-puzzle.png)工作量证明的关键特点就是，分布式系统中的请求服务的节点必须解决一个**一般难度但是可行（feasible）的问题**，但是验证问题答案的过程对于服务提供者来说却非常容易，也就是一个不容易解答但是容易验证的问题。

       这种问题通常需要消耗一定的 CPU 时间来计算某个问题的答案，目前最大的区块链网络 - 比特币（Bitcoin）就使用了工作量证明的分布式一致性算法，网络中的所有节点计算通过以下的谜题来获得当前区块的记账权：

       ![bitcoin-puzzle](https://img.draveness.me/2017-12-18-bitcoin-puzzle.png)SHA-256 作为一个哈希函数，想要通过 SHA-256 函数的输出推断出输入在目前来看可能性是**可以忽略不计的**，比特币网络就需要每一个节点不断改变 `NONCE` 来得到不同的结果 `HASH`，如果得到的 HASH 结果在小于某个范围，目前（2017.12.17）的难度是：

       ```c
       0x0000000000000000000000000000000000000000000000000000017268d8a21a
       ```

       也就是如果只计算一次 SHA-256 的值能够小于上述结果的可能性是

       1.37∗10−651.37∗10−65

       ，当前的全网算力也达到了 13,919 PH/s，这是一个非常恐怖的数字，随着网络算力的不断改变比特币也会不断改变当前问题的难度，保证每个区块被发现的时间在 10min 左右；在整个比特币网络中，谁先得到当前问题的答案就能够获得这个区块的记账权并将当前区块通过 Gossip 协议发送给尽可能多的比特币节点。

       

       工作量证明的原理其实非常简单，比特币网络选择的谜题非常好的适应了工作量证明定义中的问题，比较难以寻找同时又易于证明，我们可以简单理解为工作量证明防止错误或者无效请求的原理就是增加客户端请求服务的工作量，而适合难度的谜题又能够保证合法的请求不会受到影响。

       由于工作量证明需要消耗大量的算力，同时比特币大约 10min 才会产生一个区块，区块的大小也只有 1MB，仅仅能够包含 3、4000 笔交易，平均下来每秒只能够处理 5~7（个位数）笔交易，所以比特币网络的拥堵状况非常严重。

   - ### POS(Proof-of-Stake)

     - 权益证明是区块链网络中的使用的另一种共识算法，在基于权益证明的密码货币中，下一个区块的选择是根据不同节点的股份和时间进行随机选择的。

       由于创造新的区块并不会消耗大量的 CPU，如果它不诚实也不会失去什么，这也就给了很多节点作弊的理由，每一个节点为了最大化利益会在多条链上同时挖矿。

       ![pos-problem](https://img.draveness.me/2017-12-18-pos-problem.png)在早期的所有权证明算法中，整个网络只会奖励创建区块的节点，不存在任何惩罚，在这时每个节点在创造的多条链上同时投票才能够最大化利益，在这种情况下网络中的节点很难对一条链达成共识。

       有两种办法能够解决缺乏利害关系（nothing-at-stake）造成的问题，一种是使用 [Slasher](https://blog.ethereum.org/2014/01/15/slasher-a-punitive-proof-of-stake-algorithm/) 协议，惩罚同时在多条链上投票的节点，第二种方法时直接惩罚在错误的链上创建块的节点，总而言之就是通过算法之外的事情解决这个问题，引入激励和惩罚。

       与工作量证明相比，权益证明不需要消耗大量的电力就能够保证区块链网络的安全性，同时也不需要在每个区块中创建新的货币来激励矿工参与当前网络的运行，这也就在一定程度上缩短了达成共识所需要的时间，基于权益证明的 Ethereum 每秒大概能处理 30 笔交易左右。

   - ### DPOS(Delegated Proof-of-Stake)

     - 前面介绍的权益证明算法可以将整个区块链网络理解为一家公司，出资最多、占比最大的人有更多的机会得到话语权（记账权）；对于小股东来说，千分之几甚至万分之几的股份很难有什么作为，只能得到股份带来的分红和收益。

       但是在这里介绍的委托权益证明（DPOS，Delegated Proof-of-Stake）能够让每一个人选出可以代表自己利益的人参与到记账权的争夺中，这样多个小股东就能够通过投票选出自己的代理人，保障自己的利益。整个网络中选举出的多个节点能够在 1s 中之内对 99.9% 的交易进行确认，使用委托权益证明的 EOS 能够每秒处理几十万笔交易，同时也能够比较监管的干预。

       ![delegated-proof-of-stake-witnesses](https://img.draveness.me/2017-12-18-delegated-proof-of-stake-witnesses.png)在委托权益证明中，每一个参与者都能够选举任意数量的节点生成下一个区块，得票最多的前 N 个节点会被选择成为区块的创建者，下一个区块的创建者就会从这样一组当选者中随机选取，除此之外，N 的数量也是由整个网络投票决定的，所以可以尽可能地保证网络的去中心化。

   - 

